{"version":3,"sources":["webpack:///request.min.js","webpack:///webpack/bootstrap bca0bb96ba163129e9a3?328f","webpack:///./request.js?c61e"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","buildHttpMethodFunction","method","httpRequest","path","url","test","requestConfig","baseURL","replace","Request","mockRequest","data","req","responseData","hasSend","fetchOptions","this","options","headers","response","error","Object","assign","globalFetchOptions","prototype","queryParam","obj","arr","key","hasOwnProperty","push","split","join","jsonBody","body","JSON","stringify","formBody","send","_this","Promise","resolve","reject","fetchStartHook","fetchEndHook_1","fetchEndHook","fetch","then","contentType","get","json","text","ok","err","follow","keys","self","doFollow","shift","links","post","patch","put","deleteMethod"],"mappings":"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","file":"request.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!*********************!*\\\n  !*** multi request ***!\n  \\*********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(/*! ./request.js */1);\n\n\n/***/ },\n/* 1 */\n/*!********************!*\\\n  !*** ./request.js ***!\n  \\********************/\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction buildHttpMethodFunction(method) {\n\t    /**\n\t     * make http request user fetch API.\n\t     * if path param is a complete url then fetch ues path as url,\n\t     * else path is not a complete url string but just a path then fetch url=requestConfig.baseURL+path\n\t     * url string will been auto revised, etc: http://localhost/api//user///id/ will convert to http://localhost/api/user/id\n\t     * @param path url path\n\t     */\n\t    function httpRequest(path) {\n\t        var url = path;\n\t        if (!/^https?:\\/\\/.+$/g.test(path)) {\n\t            url = exports.requestConfig.baseURL + '/' + path;\n\t        }\n\t        url = url.replace(/\\/{2,}/g, '/').replace(/:\\//g, '://');\n\t        return new Request({ url: url, method: method });\n\t    }\n\t    return httpRequest;\n\t}\n\tvar Request = (function () {\n\t    /**\n\t     * @param fetchOptions\n\t     */\n\t    function Request(fetchOptions) {\n\t        /**\n\t         * store fetch options\n\t         */\n\t        this.options = {\n\t            headers: {}\n\t        };\n\t        /**\n\t         * has this request been send\n\t         */\n\t        this.hasSend = false;\n\t        /**\n\t         * The Response interface of the Fetch API represents the response to a request.\n\t         * @see https://developer.mozilla.org/en-US/docs/Web/API/Response\n\t         */\n\t        this.response = null;\n\t        /**\n\t         * if error happen during request error will store in there,else this will be null\n\t         */\n\t        this.error = null;\n\t        Object.assign(this.options, exports.requestConfig.globalFetchOptions, fetchOptions);\n\t    }\n\t    /**\n\t     * reset query param in request url by append ? and query param to end of url\n\t     * @param obj\n\t     */\n\t    Request.prototype.queryParam = function (obj) {\n\t        if (obj != null) {\n\t            var arr = [];\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    arr.push(key + \"=\" + obj[key]);\n\t                }\n\t            }\n\t            this.options.url = this.options.url.split('?')[0] + '?' + arr.join('&');\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t     * set request body use json\n\t     * HTTP Header Content-Type will set as application/json\n\t     * @param obj\n\t     */\n\t    Request.prototype.jsonBody = function (obj) {\n\t        this.options.body = JSON.stringify(obj);\n\t        this.options.headers['Content-Type'] = 'application/json';\n\t        return this;\n\t    };\n\t    /**\n\t     * set request body as form type\n\t     * parse obj to form string\n\t     * HTTP Header Content-Type will set as application/x-www-form-urlencoded\n\t     * @param obj\n\t     */\n\t    Request.prototype.formBody = function (obj) {\n\t        var arr = [];\n\t        for (var key in obj) {\n\t            if (obj.hasOwnProperty(key)) {\n\t                arr.push(key + \"=\" + obj[key]);\n\t            }\n\t        }\n\t        this.options.body = arr.join('&');\n\t        this.options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n\t        return this;\n\t    };\n\t    /**\n\t     * send fetch request\n\t     * get response's data\n\t     * resolve:\n\t     *      if response content-type is null,then resolve null\n\t     *      if response content-type has string json,then read response data as json and resolve pure json\n\t     *      else read response data as text and resolve plain text\n\t     */\n\t    Request.prototype.send = function () {\n\t        var _this = this;\n\t        return new Promise(function (resolve, reject) {\n\t            if (_this.hasSend) {\n\t                if (_this.error == null) {\n\t                    resolve(_this.responseData);\n\t                }\n\t                else {\n\t                    reject(_this.error);\n\t                }\n\t            }\n\t            else {\n\t                _this.hasSend = true;\n\t                var fetchStartHook = exports.requestConfig.fetchStartHook, fetchEndHook_1 = exports.requestConfig.fetchEndHook;\n\t                fetchStartHook && fetchStartHook(_this);\n\t                fetch(_this.options.url, _this.options).then(function (response) {\n\t                    _this.response = response;\n\t                    var contentType = response.headers.get('content-type');\n\t                    if (contentType == null) {\n\t                        return Promise.resolve();\n\t                    }\n\t                    else {\n\t                        if (/.*json.*/.test(contentType)) {\n\t                            //noinspection JSUnresolvedFunction\n\t                            return response.json();\n\t                        }\n\t                        else {\n\t                            return response.text();\n\t                        }\n\t                    }\n\t                }).then(function (data) {\n\t                    _this.responseData = data;\n\t                    if (_this.response.ok) {\n\t                        return Promise.resolve(data);\n\t                    }\n\t                    else {\n\t                        return Promise.reject(data);\n\t                    }\n\t                }).then(function (data) {\n\t                    fetchEndHook_1 && fetchEndHook_1(_this);\n\t                    resolve(data);\n\t                }).catch(function (err) {\n\t                    _this.error = err;\n\t                    fetchEndHook_1 && fetchEndHook_1(_this);\n\t                    reject(_this);\n\t                });\n\t            }\n\t        });\n\t    };\n\t    /**\n\t     * send request follow _links's href\n\t     * resolve:\n\t     *      if response content-type is null,then resolve null\n\t     *      if response content-type has string json,then read response data as json and resolve pure json\n\t     *      else read response data as text and resolve plain text\n\t     */\n\t    Request.prototype.follow = function (keys) {\n\t        var _this = this;\n\t        var self = this;\n\t        return new Promise(function (resolve, reject) {\n\t            function doFollow(data) {\n\t                var key = keys.shift();\n\t                if (key) {\n\t                    var links = data['_links'];\n\t                    var url = links[key];\n\t                    if (url != null) {\n\t                        url = url['href'];\n\t                        exports.get(url).send().then(function (data) {\n\t                            doFollow(data);\n\t                        }).catch(function (self) {\n\t                            reject(self);\n\t                        });\n\t                    }\n\t                    else {\n\t                        self.error = \"no key=\" + key + \" in links \" + JSON.stringify(links, null, 4);\n\t                        reject(this);\n\t                    }\n\t                }\n\t                else {\n\t                    resolve(data);\n\t                }\n\t            }\n\t            _this.send().then(function (data) {\n\t                doFollow(data);\n\t            }).catch(function (self) {\n\t                reject(self);\n\t            });\n\t        });\n\t    };\n\t    return Request;\n\t}());\n\texports.Request = Request;\n\texports.requestConfig = {\n\t    globalFetchOptions: {},\n\t    baseURL: '/',\n\t    fetchStartHook: null,\n\t    fetchEndHook: null\n\t};\n\t/**\n\t * make http get request\n\t * @param path url path\n\t */\n\texports.get = buildHttpMethodFunction('GET');\n\t/**\n\t * make http post request\n\t * @param path url path\n\t */\n\texports.post = buildHttpMethodFunction('POST');\n\t/**\n\t * make http patch request\n\t * @param path url path\n\t */\n\texports.patch = buildHttpMethodFunction('PATCH');\n\t/**\n\t * make http put request\n\t * @param path url path\n\t */\n\texports.put = buildHttpMethodFunction('PUT');\n\t//noinspection ReservedWordAsName\n\t/**\n\t * make http remove request\n\t * @param path url path\n\t */\n\texports.deleteMethod = buildHttpMethodFunction('DELETE');\n\t/**\n\t * mockRequest a request with data\n\t * @param {object} data\n\t */\n\tfunction mockRequest(data) {\n\t    var url = data['_links']['self']['href'];\n\t    var req = new Request({ url: url, method: 'GET' });\n\t    req.responseData = data;\n\t    req.hasSend = true;\n\t    return req;\n\t}\n\texports.mockRequest = mockRequest;\n\t//# sourceMappingURL=request.js.map\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** request.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap bca0bb96ba163129e9a3\n **/","\"use strict\";\nfunction buildHttpMethodFunction(method) {\n    /**\n     * make http request user fetch API.\n     * if path param is a complete url then fetch ues path as url,\n     * else path is not a complete url string but just a path then fetch url=requestConfig.baseURL+path\n     * url string will been auto revised, etc: http://localhost/api//user///id/ will convert to http://localhost/api/user/id\n     * @param path url path\n     */\n    function httpRequest(path) {\n        var url = path;\n        if (!/^https?:\\/\\/.+$/g.test(path)) {\n            url = exports.requestConfig.baseURL + '/' + path;\n        }\n        url = url.replace(/\\/{2,}/g, '/').replace(/:\\//g, '://');\n        return new Request({ url: url, method: method });\n    }\n    return httpRequest;\n}\nvar Request = (function () {\n    /**\n     * @param fetchOptions\n     */\n    function Request(fetchOptions) {\n        /**\n         * store fetch options\n         */\n        this.options = {\n            headers: {}\n        };\n        /**\n         * has this request been send\n         */\n        this.hasSend = false;\n        /**\n         * The Response interface of the Fetch API represents the response to a request.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Response\n         */\n        this.response = null;\n        /**\n         * if error happen during request error will store in there,else this will be null\n         */\n        this.error = null;\n        Object.assign(this.options, exports.requestConfig.globalFetchOptions, fetchOptions);\n    }\n    /**\n     * reset query param in request url by append ? and query param to end of url\n     * @param obj\n     */\n    Request.prototype.queryParam = function (obj) {\n        if (obj != null) {\n            var arr = [];\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    arr.push(key + \"=\" + obj[key]);\n                }\n            }\n            this.options.url = this.options.url.split('?')[0] + '?' + arr.join('&');\n        }\n        return this;\n    };\n    /**\n     * set request body use json\n     * HTTP Header Content-Type will set as application/json\n     * @param obj\n     */\n    Request.prototype.jsonBody = function (obj) {\n        this.options.body = JSON.stringify(obj);\n        this.options.headers['Content-Type'] = 'application/json';\n        return this;\n    };\n    /**\n     * set request body as form type\n     * parse obj to form string\n     * HTTP Header Content-Type will set as application/x-www-form-urlencoded\n     * @param obj\n     */\n    Request.prototype.formBody = function (obj) {\n        var arr = [];\n        for (var key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                arr.push(key + \"=\" + obj[key]);\n            }\n        }\n        this.options.body = arr.join('&');\n        this.options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n        return this;\n    };\n    /**\n     * send fetch request\n     * get response's data\n     * resolve:\n     *      if response content-type is null,then resolve null\n     *      if response content-type has string json,then read response data as json and resolve pure json\n     *      else read response data as text and resolve plain text\n     */\n    Request.prototype.send = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            if (_this.hasSend) {\n                if (_this.error == null) {\n                    resolve(_this.responseData);\n                }\n                else {\n                    reject(_this.error);\n                }\n            }\n            else {\n                _this.hasSend = true;\n                var fetchStartHook = exports.requestConfig.fetchStartHook, fetchEndHook_1 = exports.requestConfig.fetchEndHook;\n                fetchStartHook && fetchStartHook(_this);\n                fetch(_this.options.url, _this.options).then(function (response) {\n                    _this.response = response;\n                    var contentType = response.headers.get('content-type');\n                    if (contentType == null) {\n                        return Promise.resolve();\n                    }\n                    else {\n                        if (/.*json.*/.test(contentType)) {\n                            //noinspection JSUnresolvedFunction\n                            return response.json();\n                        }\n                        else {\n                            return response.text();\n                        }\n                    }\n                }).then(function (data) {\n                    _this.responseData = data;\n                    if (_this.response.ok) {\n                        return Promise.resolve(data);\n                    }\n                    else {\n                        return Promise.reject(data);\n                    }\n                }).then(function (data) {\n                    fetchEndHook_1 && fetchEndHook_1(_this);\n                    resolve(data);\n                }).catch(function (err) {\n                    _this.error = err;\n                    fetchEndHook_1 && fetchEndHook_1(_this);\n                    reject(_this);\n                });\n            }\n        });\n    };\n    /**\n     * send request follow _links's href\n     * resolve:\n     *      if response content-type is null,then resolve null\n     *      if response content-type has string json,then read response data as json and resolve pure json\n     *      else read response data as text and resolve plain text\n     */\n    Request.prototype.follow = function (keys) {\n        var _this = this;\n        var self = this;\n        return new Promise(function (resolve, reject) {\n            function doFollow(data) {\n                var key = keys.shift();\n                if (key) {\n                    var links = data['_links'];\n                    var url = links[key];\n                    if (url != null) {\n                        url = url['href'];\n                        exports.get(url).send().then(function (data) {\n                            doFollow(data);\n                        }).catch(function (self) {\n                            reject(self);\n                        });\n                    }\n                    else {\n                        self.error = \"no key=\" + key + \" in links \" + JSON.stringify(links, null, 4);\n                        reject(this);\n                    }\n                }\n                else {\n                    resolve(data);\n                }\n            }\n            _this.send().then(function (data) {\n                doFollow(data);\n            }).catch(function (self) {\n                reject(self);\n            });\n        });\n    };\n    return Request;\n}());\nexports.Request = Request;\nexports.requestConfig = {\n    globalFetchOptions: {},\n    baseURL: '/',\n    fetchStartHook: null,\n    fetchEndHook: null\n};\n/**\n * make http get request\n * @param path url path\n */\nexports.get = buildHttpMethodFunction('GET');\n/**\n * make http post request\n * @param path url path\n */\nexports.post = buildHttpMethodFunction('POST');\n/**\n * make http patch request\n * @param path url path\n */\nexports.patch = buildHttpMethodFunction('PATCH');\n/**\n * make http put request\n * @param path url path\n */\nexports.put = buildHttpMethodFunction('PUT');\n//noinspection ReservedWordAsName\n/**\n * make http remove request\n * @param path url path\n */\nexports.deleteMethod = buildHttpMethodFunction('DELETE');\n/**\n * mockRequest a request with data\n * @param {object} data\n */\nfunction mockRequest(data) {\n    var url = data['_links']['self']['href'];\n    var req = new Request({ url: url, method: 'GET' });\n    req.responseData = data;\n    req.hasSend = true;\n    return req;\n}\nexports.mockRequest = mockRequest;\n//# sourceMappingURL=request.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./request.js\n ** module id = 1\n ** module chunks = 0 1\n **/"],"sourceRoot":""}